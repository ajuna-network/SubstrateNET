//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Ajuna.NetApi;
using Ajuna.NetApi.Model.Extrinsics;
using Ajuna.NetApi.Model.Meta;
using Ajuna.NetApi.Model.Types;
using Ajuna.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace SubstrateNET.NetApi.Generated.Storage
{
    
    
    public sealed class StakingStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        public StakingStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ValidatorCount"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinimumValidatorCount"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Invulnerables"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Base.BaseVec<SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Bonded"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinNominatorBond"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinValidatorBond"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinCommission"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Ledger"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.StakingLedger)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Payee"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumRewardDestination)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Validators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.ValidatorPrefs)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForValidators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxValidatorsCount"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Nominators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.Nominations)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForNominators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxNominatorsCount"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CurrentEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ActiveEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.ActiveEraInfo)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStartSessionIndex"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakers"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.Exposure)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakersClipped"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.Exposure)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasValidatorPrefs"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.ValidatorPrefs)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasValidatorReward"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasRewardPoints"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.EraRewardPoints)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasTotalStake"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ForceEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumForcing)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SlashRewardFraction"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CanceledSlashPayout"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "UnappliedSlashes"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(Ajuna.NetApi.Model.Types.Base.BaseVec<SubstrateNET.NetApi.Generated.Model.pallet_staking.UnappliedSlash>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "BondedEras"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, Ajuna.NetApi.Model.Types.Primitive.U32>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ValidatorSlashInEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(Ajuna.NetApi.Model.Types.Base.BaseTuple<SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Ajuna.NetApi.Model.Types.Primitive.U128>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "NominatorSlashInEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32>), typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SlashingSpans"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.slashing.SlashingSpans)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SpanSlash"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Base.BaseTuple<SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32, Ajuna.NetApi.Model.Types.Primitive.U32>), typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.slashing.SpanRecord)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CurrentPlannedSession"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "OffendingValidators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, Ajuna.NetApi.Model.Types.Primitive.Bool>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "StorageVersion"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumReleases)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ChillThreshold"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Percent)));
        }
        
        /// <summary>
        /// >> ValidatorCountParams
        ///  The ideal number of active validators.
        /// </summary>
        public static string ValidatorCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorCount", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of active validators.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> ValidatorCount(CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorCountParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> MinimumValidatorCountParams
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public static string MinimumValidatorCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinimumValidatorCount", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinimumValidatorCount
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> MinimumValidatorCount(CancellationToken token)
        {
            string parameters = StakingStorage.MinimumValidatorCountParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> InvulnerablesParams
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public static string InvulnerablesParams()
        {
            return RequestGenerator.GetStorage("Staking", "Invulnerables", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Base.BaseVec<SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32>> Invulnerables(CancellationToken token)
        {
            string parameters = StakingStorage.InvulnerablesParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Base.BaseVec<SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32>>(parameters, token);
        }
        
        /// <summary>
        /// >> BondedParams
        ///  Map from all locked "stash" accounts to the controller account.
        /// </summary>
        public static string BondedParams(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Bonded", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> Bonded(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.BondedParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32>(parameters, token);
        }
        
        /// <summary>
        /// >> MinNominatorBondParams
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public static string MinNominatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinNominatorBond", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> MinNominatorBond(CancellationToken token)
        {
            string parameters = StakingStorage.MinNominatorBondParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> MinValidatorBondParams
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public static string MinValidatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinValidatorBond", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> MinValidatorBond(CancellationToken token)
        {
            string parameters = StakingStorage.MinValidatorBondParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> MinCommissionParams
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        public static string MinCommissionParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinCommission", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinCommission
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill> MinCommission(CancellationToken token)
        {
            string parameters = StakingStorage.MinCommissionParams();
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill>(parameters, token);
        }
        
        /// <summary>
        /// >> LedgerParams
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// </summary>
        public static string LedgerParams(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Ledger", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.StakingLedger> Ledger(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.LedgerParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.StakingLedger>(parameters, token);
        }
        
        /// <summary>
        /// >> PayeeParams
        ///  Where the reward payment should be made. Keyed by stash.
        /// </summary>
        public static string PayeeParams(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Payee", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumRewardDestination> Payee(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.PayeeParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumRewardDestination>(parameters, token);
        }
        
        /// <summary>
        /// >> ValidatorsParams
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// </summary>
        public static string ValidatorsParams(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Validators", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.ValidatorPrefs> Validators(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorsParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.ValidatorPrefs>(parameters, token);
        }
        
        /// <summary>
        /// >> CounterForValidatorsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForValidatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForValidators", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForValidators
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> CounterForValidators(CancellationToken token)
        {
            string parameters = StakingStorage.CounterForValidatorsParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> MaxValidatorsCountParams
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxValidatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxValidatorsCount", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> MaxValidatorsCount(CancellationToken token)
        {
            string parameters = StakingStorage.MaxValidatorsCountParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> NominatorsParams
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// </summary>
        public static string NominatorsParams(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Nominators", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.Nominations> Nominators(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.NominatorsParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.Nominations>(parameters, token);
        }
        
        /// <summary>
        /// >> CounterForNominatorsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForNominatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForNominators", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForNominators
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> CounterForNominators(CancellationToken token)
        {
            string parameters = StakingStorage.CounterForNominatorsParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> MaxNominatorsCountParams
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxNominatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxNominatorsCount", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> MaxNominatorsCount(CancellationToken token)
        {
            string parameters = StakingStorage.MaxNominatorsCountParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> CurrentEraParams
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public static string CurrentEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "CurrentEra", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CurrentEra
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> CurrentEra(CancellationToken token)
        {
            string parameters = StakingStorage.CurrentEraParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> ActiveEraParams
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public static string ActiveEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ActiveEra", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.ActiveEraInfo> ActiveEra(CancellationToken token)
        {
            string parameters = StakingStorage.ActiveEraParams();
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.ActiveEraInfo>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasStartSessionIndexParams
        ///  The session index at which the era start for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public static string ErasStartSessionIndexParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStartSessionIndex", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasStartSessionIndex
        ///  The session index at which the era start for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> ErasStartSessionIndex(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStartSessionIndexParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasStakersParams
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public static string ErasStakersParams(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakers", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasStakers
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.Exposure> ErasStakers(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.Exposure>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasStakersClippedParams
        ///  Clipped Exposure of validator at era.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxNominatorRewardedPerValidator` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public static string ErasStakersClippedParams(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakersClipped", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasStakersClipped
        ///  Clipped Exposure of validator at era.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxNominatorRewardedPerValidator` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.Exposure> ErasStakersClipped(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersClippedParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.Exposure>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasValidatorPrefsParams
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        /// </summary>
        public static string ErasValidatorPrefsParams(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorPrefs", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.ValidatorPrefs> ErasValidatorPrefs(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasValidatorPrefsParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.ValidatorPrefs>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasValidatorRewardParams
        ///  The total validator era payout for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public static string ErasValidatorRewardParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorReward", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> ErasValidatorReward(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasValidatorRewardParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasRewardPointsParams
        ///  Rewards for the last `HISTORY_DEPTH` eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public static string ErasRewardPointsParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasRewardPoints", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last `HISTORY_DEPTH` eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.EraRewardPoints> ErasRewardPoints(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasRewardPointsParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.EraRewardPoints>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasTotalStakeParams
        ///  The total amount staked for the last `HISTORY_DEPTH` eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public static string ErasTotalStakeParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasTotalStake", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last `HISTORY_DEPTH` eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> ErasTotalStake(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasTotalStakeParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> ForceEraParams
        ///  Mode of era forcing.
        /// </summary>
        public static string ForceEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ForceEra", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumForcing> ForceEra(CancellationToken token)
        {
            string parameters = StakingStorage.ForceEraParams();
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumForcing>(parameters, token);
        }
        
        /// <summary>
        /// >> SlashRewardFractionParams
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public static string SlashRewardFractionParams()
        {
            return RequestGenerator.GetStorage("Staking", "SlashRewardFraction", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill> SlashRewardFraction(CancellationToken token)
        {
            string parameters = StakingStorage.SlashRewardFractionParams();
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill>(parameters, token);
        }
        
        /// <summary>
        /// >> CanceledSlashPayoutParams
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public static string CanceledSlashPayoutParams()
        {
            return RequestGenerator.GetStorage("Staking", "CanceledSlashPayout", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> CanceledSlashPayout(CancellationToken token)
        {
            string parameters = StakingStorage.CanceledSlashPayoutParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> UnappliedSlashesParams
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public static string UnappliedSlashesParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "UnappliedSlashes", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Base.BaseVec<SubstrateNET.NetApi.Generated.Model.pallet_staking.UnappliedSlash>> UnappliedSlashes(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.UnappliedSlashesParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Base.BaseVec<SubstrateNET.NetApi.Generated.Model.pallet_staking.UnappliedSlash>>(parameters, token);
        }
        
        /// <summary>
        /// >> BondedErasParams
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public static string BondedErasParams()
        {
            return RequestGenerator.GetStorage("Staking", "BondedEras", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, Ajuna.NetApi.Model.Types.Primitive.U32>>> BondedEras(CancellationToken token)
        {
            string parameters = StakingStorage.BondedErasParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, Ajuna.NetApi.Model.Types.Primitive.U32>>>(parameters, token);
        }
        
        /// <summary>
        /// >> ValidatorSlashInEraParams
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public static string ValidatorSlashInEraParams(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorSlashInEra", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Base.BaseTuple<SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Ajuna.NetApi.Model.Types.Primitive.U128>> ValidatorSlashInEra(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorSlashInEraParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Base.BaseTuple<SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Perbill, Ajuna.NetApi.Model.Types.Primitive.U128>>(parameters, token);
        }
        
        /// <summary>
        /// >> NominatorSlashInEraParams
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public static string NominatorSlashInEraParams(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "NominatorSlashInEra", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> NominatorSlashInEra
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> NominatorSlashInEra(Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.NominatorSlashInEraParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> SlashingSpansParams
        ///  Slashing spans for stash accounts.
        /// </summary>
        public static string SlashingSpansParams(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "SlashingSpans", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SlashingSpans
        ///  Slashing spans for stash accounts.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.slashing.SlashingSpans> SlashingSpans(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.SlashingSpansParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.slashing.SlashingSpans>(parameters, token);
        }
        
        /// <summary>
        /// >> SpanSlashParams
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public static string SpanSlashParams(Ajuna.NetApi.Model.Types.Base.BaseTuple<SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32, Ajuna.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("Staking", "SpanSlash", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SpanSlash
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.slashing.SpanRecord> SpanSlash(Ajuna.NetApi.Model.Types.Base.BaseTuple<SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32, Ajuna.NetApi.Model.Types.Primitive.U32> key, CancellationToken token)
        {
            string parameters = StakingStorage.SpanSlashParams(key);
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.slashing.SpanRecord>(parameters, token);
        }
        
        /// <summary>
        /// >> CurrentPlannedSessionParams
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public static string CurrentPlannedSessionParams()
        {
            return RequestGenerator.GetStorage("Staking", "CurrentPlannedSession", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CurrentPlannedSession
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> CurrentPlannedSession(CancellationToken token)
        {
            string parameters = StakingStorage.CurrentPlannedSessionParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> OffendingValidatorsParams
        ///  Indices of validators that have offended in the active era and whether they are currently
        ///  disabled.
        /// 
        ///  This value should be a superset of disabled validators since not all offences lead to the
        ///  validator being disabled (if there was no slash). This is needed to track the percentage of
        ///  validators that have offended in the current era, ensuring a new era is forced if
        ///  `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
        ///  whether a given validator has previously offended using binary search. It gets cleared when
        ///  the era ends.
        /// </summary>
        public static string OffendingValidatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "OffendingValidators", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> OffendingValidators
        ///  Indices of validators that have offended in the active era and whether they are currently
        ///  disabled.
        /// 
        ///  This value should be a superset of disabled validators since not all offences lead to the
        ///  validator being disabled (if there was no slash). This is needed to track the percentage of
        ///  validators that have offended in the current era, ensuring a new era is forced if
        ///  `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
        ///  whether a given validator has previously offended using binary search. It gets cleared when
        ///  the era ends.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, Ajuna.NetApi.Model.Types.Primitive.Bool>>> OffendingValidators(CancellationToken token)
        {
            string parameters = StakingStorage.OffendingValidatorsParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, Ajuna.NetApi.Model.Types.Primitive.Bool>>>(parameters, token);
        }
        
        /// <summary>
        /// >> StorageVersionParams
        ///  True if network has been upgraded to this version.
        ///  Storage version of the pallet.
        /// 
        ///  This is set to v7.0.0 for new networks.
        /// </summary>
        public static string StorageVersionParams()
        {
            return RequestGenerator.GetStorage("Staking", "StorageVersion", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> StorageVersion
        ///  True if network has been upgraded to this version.
        ///  Storage version of the pallet.
        /// 
        ///  This is set to v7.0.0 for new networks.
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumReleases> StorageVersion(CancellationToken token)
        {
            string parameters = StakingStorage.StorageVersionParams();
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumReleases>(parameters, token);
        }
        
        /// <summary>
        /// >> ChillThresholdParams
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public static string ChillThresholdParams()
        {
            return RequestGenerator.GetStorage("Staking", "ChillThreshold", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public async Task<SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Percent> ChillThreshold(CancellationToken token)
        {
            string parameters = StakingStorage.ChillThresholdParams();
            return await _client.GetStorageAsync<SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Percent>(parameters, token);
        }
    }
    
    public sealed class StakingCalls
    {
        
        /// <summary>
        /// >> bond
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Bond(SubstrateNET.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress controller, Ajuna.NetApi.Model.Types.Base.BaseCom<Ajuna.NetApi.Model.Types.Primitive.U128> value, SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumRewardDestination payee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controller.Encode());
            byteArray.AddRange(value.Encode());
            byteArray.AddRange(payee.Encode());
            return new Method(10, "Staking", 0, "bond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> bond_extra
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method BondExtra(Ajuna.NetApi.Model.Types.Base.BaseCom<Ajuna.NetApi.Model.Types.Primitive.U128> max_additional)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(max_additional.Encode());
            return new Method(10, "Staking", 1, "bond_extra", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> unbond
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Unbond(Ajuna.NetApi.Model.Types.Base.BaseCom<Ajuna.NetApi.Model.Types.Primitive.U128> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            return new Method(10, "Staking", 2, "unbond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> withdraw_unbonded
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method WithdrawUnbonded(Ajuna.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(10, "Staking", 3, "withdraw_unbonded", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> validate
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Validate(SubstrateNET.NetApi.Generated.Model.pallet_staking.ValidatorPrefs prefs)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(prefs.Encode());
            return new Method(10, "Staking", 4, "validate", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> nominate
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Nominate(Ajuna.NetApi.Model.Types.Base.BaseVec<SubstrateNET.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress> targets)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(targets.Encode());
            return new Method(10, "Staking", 5, "nominate", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> chill
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Chill()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(10, "Staking", 6, "chill", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_payee
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetPayee(SubstrateNET.NetApi.Generated.Model.pallet_staking.EnumRewardDestination payee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(payee.Encode());
            return new Method(10, "Staking", 7, "set_payee", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_controller
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetController(SubstrateNET.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress controller)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controller.Encode());
            return new Method(10, "Staking", 8, "set_controller", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_validator_count
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetValidatorCount(Ajuna.NetApi.Model.Types.Base.BaseCom<Ajuna.NetApi.Model.Types.Primitive.U32> @new)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(@new.Encode());
            return new Method(10, "Staking", 9, "set_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> increase_validator_count
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method IncreaseValidatorCount(Ajuna.NetApi.Model.Types.Base.BaseCom<Ajuna.NetApi.Model.Types.Primitive.U32> additional)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(additional.Encode());
            return new Method(10, "Staking", 10, "increase_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> scale_validator_count
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ScaleValidatorCount(SubstrateNET.NetApi.Generated.Model.sp_arithmetic.per_things.Percent factor)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(factor.Encode());
            return new Method(10, "Staking", 11, "scale_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_no_eras
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceNoEras()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(10, "Staking", 12, "force_no_eras", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_new_era
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceNewEra()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(10, "Staking", 13, "force_new_era", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_invulnerables
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetInvulnerables(Ajuna.NetApi.Model.Types.Base.BaseVec<SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32> invulnerables)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(invulnerables.Encode());
            return new Method(10, "Staking", 14, "set_invulnerables", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_unstake
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceUnstake(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 stash, Ajuna.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(10, "Staking", 15, "force_unstake", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_new_era_always
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceNewEraAlways()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(10, "Staking", 16, "force_new_era_always", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> cancel_deferred_slash
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method CancelDeferredSlash(Ajuna.NetApi.Model.Types.Primitive.U32 era, Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Primitive.U32> slash_indices)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(era.Encode());
            byteArray.AddRange(slash_indices.Encode());
            return new Method(10, "Staking", 17, "cancel_deferred_slash", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> payout_stakers
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method PayoutStakers(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 validator_stash, Ajuna.NetApi.Model.Types.Primitive.U32 era)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(validator_stash.Encode());
            byteArray.AddRange(era.Encode());
            return new Method(10, "Staking", 18, "payout_stakers", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> rebond
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Rebond(Ajuna.NetApi.Model.Types.Base.BaseCom<Ajuna.NetApi.Model.Types.Primitive.U128> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            return new Method(10, "Staking", 19, "rebond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> reap_stash
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ReapStash(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 stash, Ajuna.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(10, "Staking", 20, "reap_stash", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> kick
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Kick(Ajuna.NetApi.Model.Types.Base.BaseVec<SubstrateNET.NetApi.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress> who)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(who.Encode());
            return new Method(10, "Staking", 21, "kick", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_staking_configs
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetStakingConfigs(SubstrateNET.NetApi.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp min_nominator_bond, SubstrateNET.NetApi.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp min_validator_bond, SubstrateNET.NetApi.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp max_nominator_count, SubstrateNET.NetApi.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp max_validator_count, SubstrateNET.NetApi.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp chill_threshold, SubstrateNET.NetApi.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp min_commission)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(min_nominator_bond.Encode());
            byteArray.AddRange(min_validator_bond.Encode());
            byteArray.AddRange(max_nominator_count.Encode());
            byteArray.AddRange(max_validator_count.Encode());
            byteArray.AddRange(chill_threshold.Encode());
            byteArray.AddRange(min_commission.Encode());
            return new Method(10, "Staking", 22, "set_staking_configs", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> chill_other
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ChillOther(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 controller)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controller.Encode());
            return new Method(10, "Staking", 23, "chill_other", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_apply_min_commission
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceApplyMinCommission(SubstrateNET.NetApi.Generated.Model.sp_core.crypto.AccountId32 validator_stash)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(validator_stash.Encode());
            return new Method(10, "Staking", 24, "force_apply_min_commission", byteArray.ToArray());
        }
    }
    
    public enum StakingErrors
    {
        
        /// <summary>
        /// >> NotController
        /// Not a controller account.
        /// </summary>
        NotController,
        
        /// <summary>
        /// >> NotStash
        /// Not a stash account.
        /// </summary>
        NotStash,
        
        /// <summary>
        /// >> AlreadyBonded
        /// Stash is already bonded.
        /// </summary>
        AlreadyBonded,
        
        /// <summary>
        /// >> AlreadyPaired
        /// Controller is already paired.
        /// </summary>
        AlreadyPaired,
        
        /// <summary>
        /// >> EmptyTargets
        /// Targets cannot be empty.
        /// </summary>
        EmptyTargets,
        
        /// <summary>
        /// >> DuplicateIndex
        /// Duplicate index.
        /// </summary>
        DuplicateIndex,
        
        /// <summary>
        /// >> InvalidSlashIndex
        /// Slash record index out of bounds.
        /// </summary>
        InvalidSlashIndex,
        
        /// <summary>
        /// >> InsufficientBond
        /// Cannot have a validator or nominator role, with value less than the minimum defined by
        /// governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
        /// intention, `chill` first to remove one's role as validator/nominator.
        /// </summary>
        InsufficientBond,
        
        /// <summary>
        /// >> NoMoreChunks
        /// Can not schedule more unlock chunks.
        /// </summary>
        NoMoreChunks,
        
        /// <summary>
        /// >> NoUnlockChunk
        /// Can not rebond without unlocking chunks.
        /// </summary>
        NoUnlockChunk,
        
        /// <summary>
        /// >> FundedTarget
        /// Attempting to target a stash that still has funds.
        /// </summary>
        FundedTarget,
        
        /// <summary>
        /// >> InvalidEraToReward
        /// Invalid era to reward.
        /// </summary>
        InvalidEraToReward,
        
        /// <summary>
        /// >> InvalidNumberOfNominations
        /// Invalid number of nominations.
        /// </summary>
        InvalidNumberOfNominations,
        
        /// <summary>
        /// >> NotSortedAndUnique
        /// Items are not sorted and unique.
        /// </summary>
        NotSortedAndUnique,
        
        /// <summary>
        /// >> AlreadyClaimed
        /// Rewards for this era have already been claimed for this validator.
        /// </summary>
        AlreadyClaimed,
        
        /// <summary>
        /// >> IncorrectHistoryDepth
        /// Incorrect previous history depth input provided.
        /// </summary>
        IncorrectHistoryDepth,
        
        /// <summary>
        /// >> IncorrectSlashingSpans
        /// Incorrect number of slashing spans provided.
        /// </summary>
        IncorrectSlashingSpans,
        
        /// <summary>
        /// >> BadState
        /// Internal state has become somehow corrupted and the operation cannot continue.
        /// </summary>
        BadState,
        
        /// <summary>
        /// >> TooManyTargets
        /// Too many nomination targets supplied.
        /// </summary>
        TooManyTargets,
        
        /// <summary>
        /// >> BadTarget
        /// A nomination target was supplied that was blocked or otherwise not a validator.
        /// </summary>
        BadTarget,
        
        /// <summary>
        /// >> CannotChillOther
        /// The user has enough bond and thus cannot be chilled forcefully by an external person.
        /// </summary>
        CannotChillOther,
        
        /// <summary>
        /// >> TooManyNominators
        /// There are too many nominators in the system. Governance needs to adjust the staking
        /// settings to keep things safe for the runtime.
        /// </summary>
        TooManyNominators,
        
        /// <summary>
        /// >> TooManyValidators
        /// There are too many validators in the system. Governance needs to adjust the staking
        /// settings to keep things safe for the runtime.
        /// </summary>
        TooManyValidators,
        
        /// <summary>
        /// >> CommissionTooLow
        /// Commission is too low. Must be at least `MinCommission`.
        /// </summary>
        CommissionTooLow,
        
        /// <summary>
        /// >> BoundNotMet
        /// Some bound is not met.
        /// </summary>
        BoundNotMet,
    }
}
